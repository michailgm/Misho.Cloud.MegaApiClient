<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Misho.Security.Cryptography.Core</name>
    </assembly>
    <members>
        <member name="T:Misho.Security.Cryptography.BigInteger">
            <summary>
            This is a BigInteger class. Holds integer that is more than 64-bit (long).
            </summary>
            <remarks>
            This class contains overloaded arithmetic operators(+, -, *, /, %), bitwise operators(&amp;, |) and other
            operations that can be done with normal integer. It also contains implementation of various prime test.
            This class also contains methods dealing with cryptography such as generating prime number, generating 
            a coprime number.
            </remarks>
        </member>
        <member name="F:Misho.Security.Cryptography.BigInteger.maxLength">
            <summary>
            maximum length of the BigInteger in uint (4 bytes)
            change this to suit the required level of precision.
            </summary>
        </member>
        <member name="F:Misho.Security.Cryptography.BigInteger.primesBelow2000">
            <summary>
            primes smaller than 2000 to test the generated prime number
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor">
            <summary>
            Default constructor for BigInteger of value 0
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.Int64)">
            <summary>
            Constructor (Default value provided by long)
            </summary>
            <param name="value">Turn the long value into BigInteger type</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.UInt64)">
            <summary>
            Constructor (Default value provided by ulong)
            </summary>
            <param name="value">Turn the unsigned long value into BigInteger type</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Constructor (Default value provided by BigInteger)
            </summary>
            <param name="bi"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Constructor (Default value provided by a string of digits of the specified base)
            </summary>
            <example>
            To initialize "a" with the default value of 1234 in base 10:
                 BigInteger a = new BigInteger("1234", 10)
            To initialize "a" with the default value of -0x1D4F in base 16:
                 BigInteger a = new BigInteger("-1D4F", 16)
            </example>
            
            <param name="value">String value in the format of [sign][magnitude]</param>
            <param name="radix">The base of value</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.Byte[])">
            <summary>
             Constructor(Default value provided by an array of bytes)
             The lowest index of the input byte array(i.e[0]) should contain the
            most significant byte of the number, and the highest index should
             contain the least significant byte.
             E.g.
             To initialize "a" with the default value of 0x1D4F in base 16
                  byte[] temp = { 0x1D, 0x4F };
            BigInteger a = new BigInteger(temp)
             Note that this method of initialization does not allow the
             sign to be specified.
            </summary>
            <param name="inData"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.Collections.Generic.IList{System.Byte},System.Int32,System.Int32)">
            <summary>
            Constructor (Default value provided by an array of bytes of the specified length.)
            </summary>
            <param name="inData">A list of byte values</param>
            <param name="length">Default -1</param>
            <param name="offset">Default 0</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.#ctor(System.UInt32[])">
            <summary>
             Constructor (Default value provided by an array of unsigned integers)
            </summary>
            <param name="inData">Array of unsigned integer</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Implicit(System.Int64)~Misho.Security.Cryptography.BigInteger">
            <summary>
            Cast a type long value to type BigInteger value
            </summary>
            <param name="value">A long value</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Implicit(System.UInt64)~Misho.Security.Cryptography.BigInteger">
            <summary>
            Cast a type ulong value to type BigInteger value
            </summary>
            <param name="value">An unsigned long value</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Implicit(System.Int32)~Misho.Security.Cryptography.BigInteger">
            <summary>
            Cast a type int value to type BigInteger value
            </summary>
            <param name="value">An int value</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Implicit(System.UInt32)~Misho.Security.Cryptography.BigInteger">
            <summary>
            Cast a type uint value to type BigInteger value
            </summary>
            <param name="value">An unsigned int value</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Addition(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of addition operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Result of the addition of 2 BigIntegers</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Increment(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of the unary ++ operator, which increments BigInteger by 1
            </summary>
            <param name="bi1">A BigInteger</param>
            <returns>Incremented BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Subtraction(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of subtraction operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Result of the subtraction of 2 BigIntegers</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Decrement(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of the unary -- operator, decrements BigInteger by 1
            </summary>
            <param name="bi1">A BigInteger</param>
            <returns>Decremented BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Multiply(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of multiplication operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Result of the multiplication of 2 BigIntegers</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_LeftShift(Misho.Security.Cryptography.BigInteger,System.Int32)">
            <summary>
            Overloading of the unary &lt;&lt; operator (left shift)
            </summary>
            <remarks>
            Shifting by a negative number is an undefined behaviour (UB).
            </remarks>
            <param name="bi1">A BigInteger</param>
            <param name="shiftVal">Left shift by shiftVal bit</param>
            <returns>Left-shifted BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_RightShift(Misho.Security.Cryptography.BigInteger,System.Int32)">
            <summary>
            Overloading of the unary &gt;&gt; operator (right shift)
            </summary>
            <remarks>
            Shifting by a negative number is an undefined behaviour (UB).
            </remarks>
            <param name="bi1">A BigInteger</param>
            <param name="shiftVal">Right shift by shiftVal bit</param>
            <returns>Right-shifted BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_OnesComplement(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of the bit-wise NOT operator (1's complement)
            </summary>
            <param name="bi1">A BigInteger</param>
            <returns>Complemented BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_UnaryNegation(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of the NEGATE operator (2's complement)
            </summary>
            <param name="bi1">A BigInteger</param>
            <returns>Negated BigInteger or default BigInteger value if bi1 is 0</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Equality(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of equality operator, allows comparing 2 BigIntegers with == operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Inequality(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of not equal operator, allows comparing 2 BigIntegers with != operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.Equals(System.Object)">
            <summary>
            Overriding of Equals method, allows comparing BigInteger with an arbitary object
            </summary>
            <param name="o">Input object, to be casted into BigInteger type for comparison</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_GreaterThan(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of greater than operator, allows comparing 2 BigIntegers with &gt; operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_LessThan(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of greater than operator, allows comparing 2 BigIntegers with &lt; operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_GreaterThanOrEqual(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of greater than or equal to operator, allows comparing 2 BigIntegers with &gt;= operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_LessThanOrEqual(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of less than or equal to operator, allows comparing 2 BigIntegers with &lt;= operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>Boolean result of the comparison</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.multiByteDivide(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
             <summary>
             Private function that supports the division of two numbers with
             a divisor that has more than 1 digit.
            
             Algorithm taken from [1]
             </summary>
             <param name="bi1"></param>
             <param name="bi2"></param>
             <param name="outQuotient"></param>
             <param name="outRemainder"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.singleByteDivide(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Private function that supports the division of two numbers with
            a divisor that has only 1 digit.
            </summary>
            <param name="bi1"></param>
            <param name="bi2"></param>
            <param name="outQuotient"></param>
            <param name="outRemainder"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Division(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of division operator
            </summary>
            <remarks>The dataLength of the divisor's absolute value must be less than maxLength</remarks>
            <param name="bi1">Dividend</param>
            <param name="bi2">Divisor</param>
            <returns>Quotient of the division</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_Modulus(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of modulus operator
            </summary>
            <remarks>The dataLength of the divisor's absolute value must be less than maxLength</remarks>
            <param name="bi1">Dividend</param>
            <param name="bi2">Divisor</param>
            <returns>Remainder of the division</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_BitwiseAnd(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of bitwise AND operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>BigInteger result after performing &amp; operation</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_BitwiseOr(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of bitwise OR operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>BigInteger result after performing | operation</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.op_ExclusiveOr(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Overloading of bitwise XOR operator
            </summary>
            <param name="bi1">First BigInteger</param>
            <param name="bi2">Second BigInteger</param>
            <returns>BigInteger result after performing ^ operation</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.max(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Compare this and a BigInteger and find the maximum one
            </summary>
            <param name="bi">BigInteger to be compared with this</param>
            <returns>The bigger value of this and bi</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.min(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Compare this and a BigInteger and find the minimum one
            </summary>
            <param name="bi">BigInteger to be compared with this</param>
            <returns>The smaller value of this and bi</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.abs">
            <summary>
            Returns the absolute value
            </summary>
            <returns>Absolute value of this</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.ToString">
            <summary>
            Returns a string representing the BigInteger in base 10
            </summary>
            <returns>string representation of the BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.ToString(System.Int32)">
            <summary>
            Returns a string representing the BigInteger in [sign][magnitude] format in the specified radix
            </summary>
            <example>If the value of BigInteger is -255 in base 10, then ToString(16) returns "-FF"</example>
            <param name="radix">Base</param>
            <returns>string representation of the BigInteger in [sign][magnitude] format</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.ToHexString">
            <summary>
            Returns a hex string showing the contains of the BigInteger
            </summary>
            <example>
            1) If the value of BigInteger is 255 in base 10, then ToHexString() returns "FF"
            2) If the value of BigInteger is -255 in base 10, thenToHexString() returns ".....FFFFFFFFFF01", which is the 2's complement representation of -255.
            </example>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.modPow(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Modulo Exponentiation
            </summary>
            <param name="exp">Exponential</param>
            <param name="n">Modulo</param>
            <returns>BigInteger result of raising this to the power of exp and then modulo n </returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.BarrettReduction(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
             <summary>
             Fast calculation of modular reduction using Barrett's reduction
             </summary>
             <remarks>
             Requires x &lt; b^(2k), where b is the base.  In this case, base is 2^32 (uint).
            
             Reference [4]
             </remarks>
             <param name="x"></param>
             <param name="n"></param>
             <param name="constant"></param>
             <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.gcd(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Returns gcd(this, bi)
            </summary>
            <param name="bi"></param>
            <returns>Greatest Common Divisor of this and bi</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.genRandomBits(System.Int32,System.Random)">
            <summary>
            Populates "this" with the specified amount of random bits
            </summary>
            <param name="bits"></param>
            <param name="rand"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.bitCount">
            <summary>
            Returns the position of the most significant bit in the BigInteger
            </summary>
            <example>
            1) The result is 1, if the value of BigInteger is 0...0000 0000
            2) The result is 1, if the value of BigInteger is 0...0000 0001
            3) The result is 2, if the value of BigInteger is 0...0000 0010
            4) The result is 2, if the value of BigInteger is 0...0000 0011
            5) The result is 5, if the value of BigInteger is 0...0001 0011
            </example>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.FermatLittleTest(System.Int32)">
             <summary>
             Probabilistic prime test based on Fermat's little theorem
             </summary>
             <remarks>
             for any a &lt; p (p does not divide a) if
                  a^(p-1) mod p != 1 then p is not prime.
            
             Otherwise, p is probably prime (pseudoprime to the chosen base).
             
             This method is fast but fails for Carmichael numbers when the randomly chosen base is a factor of the number.
             </remarks>
             <param name="confidence">Number of chosen bases</param>
             <returns>True if this is a pseudoprime to randomly chosen bases</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.RabinMillerTest(System.Int32)">
             <summary>
             Probabilistic prime test based on Rabin-Miller's
             </summary>
             <remarks>
             for any p &gt; 0 with p - 1 = 2^s * t
            
             p is probably prime (strong pseudoprime) if for any a &lt; p,
             1) a^t mod p = 1 or
             2) a^((2^j)*t) mod p = p-1 for some 0 &lt;= j &lt;= s-1
            
             Otherwise, p is composite.
             </remarks>
             <param name="confidence">Number of chosen bases</param>
             <returns>True if this is a strong pseudoprime to randomly chosen bases</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.SolovayStrassenTest(System.Int32)">
             <summary>
             Probabilistic prime test based on Solovay-Strassen (Euler Criterion)
             </summary>
             <remarks>
              p is probably prime if for any a &lt; p (a is not multiple of p),
             a^((p-1)/2) mod p = J(a, p)
            
             where J is the Jacobi symbol.
            
             Otherwise, p is composite.
             </remarks>
             <param name="confidence">Number of chosen bases</param>
             <returns>True if this is a Euler pseudoprime to randomly chosen bases</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.LucasStrongTest">
             <summary>
             Implementation of the Lucas Strong Pseudo Prime test
             </summary>
             <remarks>
             Let n be an odd number with gcd(n,D) = 1, and n - J(D, n) = 2^s * d
             with d odd and s >= 0.
            
             If Ud mod n = 0 or V2^r*d mod n = 0 for some 0 &lt;= r &lt; s, then n
             is a strong Lucas pseudoprime with parameters (P, Q).  We select
             P and Q based on Selfridge.
             </remarks>
             <returns>True if number is a strong Lucus pseudo prime</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.isProbablePrime(System.Int32)">
            <summary>
            Determines whether a number is probably prime using the Rabin-Miller's test
            </summary>
            <remarks>
            Before applying the test, the number is tested for divisibility by primes &lt; 2000
            </remarks>
            <param name="confidence">Number of chosen bases</param>
            <returns>True if this is probably prime</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.isProbablePrime">
             <summary>
             Determines whether this BigInteger is probably prime using a combination of base 2 strong pseudoprime test and Lucas strong pseudoprime test 
             </summary>
             <remarks>
             The sequence of the primality test is as follows,
            
             1) Trial divisions are carried out using prime numbers below 2000.
                if any of the primes divides this BigInteger, then it is not prime.
            
             2) Perform base 2 strong pseudoprime test.  If this BigInteger is a
                base 2 strong pseudoprime, proceed on to the next step.
            
             3) Perform strong Lucas pseudoprime test.
             
             For a detailed discussion of this primality test, see [6].
             </remarks>
             <returns>True if this is probably prime</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.IntValue">
            <summary>
            Returns the lowest 4 bytes of the BigInteger as an int
            </summary>
            <returns>Lowest 4 bytes as integer</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.LongValue">
            <summary>
            Returns the lowest 8 bytes of the BigInteger as a long
            </summary>
            <returns>Lowest 8 bytes as long</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.Jacobi(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
            <summary>
            Computes the Jacobi Symbol for 2 BigInteger a and b
            </summary>
            <remarks>
            Algorithm adapted from [3] and [4] with some optimizations
            </remarks>
            <param name="a">Any BigInteger</param>
            <param name="b">Odd BigInteger</param>
            <returns>Jacobi Symbol</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.genPseudoPrime(System.Int32,System.Int32,System.Random)">
            <summary>
            Generates a positive BigInteger that is probably prime
            </summary>
            <param name="bits">Number of bit</param>
            <param name="confidence">Number of chosen bases</param>
            <param name="rand">Random object</param>
            <returns>A probably prime number</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.genCoPrime(System.Int32,System.Random)">
            <summary>
            Generates a random number with the specified number of bits such that gcd(number, this) = 1
            </summary>
            <remarks>
            The number of bits must be greater than 0 and less than 2209
            </remarks>
            <param name="bits">Number of bit</param>
            <param name="rand">Random object</param>
            <returns>Relatively prime number of this</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.modInverse(Misho.Security.Cryptography.BigInteger)">
            <summary>
            Returns the modulo inverse of this
            </summary>
            <remarks>
            Throws ArithmeticException if the inverse does not exist.  (i.e. gcd(this, modulus) != 1)
            </remarks>
            <param name="modulus"></param>
            <returns>Modulo inverse of this</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.getBytes">
            <summary>
            Returns the value of the BigInteger as a byte array
            </summary>
            <remarks>
            The lowest index contains the MSB
            </remarks>
            <returns>Byte array containing value of the BigInteger</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.setBit(System.UInt32)">
            <summary>
            Sets the value of the specified bit to 1
            </summary>
            <remarks>
            The Least Significant Bit position is 0
            </remarks>
            <param name="bitNum">The position of bit to be changed</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.unsetBit(System.UInt32)">
            <summary>
            Sets the value of the specified bit to 0
            </summary>
            <remarks>
            The Least Significant Bit position is 0
            </remarks>
            <param name="bitNum">The position of bit to be changed</param>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.sqrt">
            <summary>
            Returns a value that is equivalent to the integer square root of this
            </summary>
            <remarks>
            The integer square root of "this" is defined as the largest integer n, such that (n * n) &lt;= this.
            Square root of negative integer is an undefined behaviour (UB).
            </remarks>
            <returns>Integer square root of this</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.LucasSequence(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger)">
             <summary>
             Returns the k_th number in the Lucas Sequence reduced modulo n
             </summary>
             <remarks>
             Uses index doubling to speed up the process.  For example, to calculate V(k),
             we maintain two numbers in the sequence V(n) and V(n+1).
            
             To obtain V(2n), we use the identity
                  V(2n) = (V(n) * V(n)) - (2 * Q^n)
             To obtain V(2n+1), we first write it as
                  V(2n+1) = V((n+1) + n)
             and use the identity
                  V(m+n) = V(m) * V(n) - Q * V(m-n)
             Hence,
                  V((n+1) + n) = V(n+1) * V(n) - Q^n * V((n+1) - n)
                               = V(n+1) * V(n) - Q^n * V(1)
                               = V(n+1) * V(n) - Q^n * P
            
             We use k in its binary expansion and perform index doubling for each
             bit position.  For each bit position that is set, we perform an
             index doubling followed by an index addition.  This means that for V(n),
             we need to update it to V(2n+1).  For V(n+1), we need to update it to
             V((2n+1)+1) = V(2*(n+1))
            
             This function returns
             [0] = U(k)
             [1] = V(k)
             [2] = Q^n
            
             Where U(0) = 0 % n, U(1) = 1 % n
                   V(0) = 2 % n, V(1) = P % n
             </remarks>
             <param name="P"></param>
             <param name="Q"></param>
             <param name="k"></param>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.BigInteger.LucasSequenceHelper(Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,Misho.Security.Cryptography.BigInteger,System.Int32)">
             <summary>
             Performs the calculation of the kth term in the Lucas Sequence.
             For details of the algorithm, see reference [9].
            
             k must be odd.  i.e LSB == 1
             </summary>
             <param name="P"></param>
             <param name="Q"></param>
             <param name="k"></param>
             <param name="n"></param>
             <param name="constant"></param>
             <param name="s"></param>
             <returns></returns>
        </member>
        <member name="T:Misho.Security.Cryptography.DamiengCrc32">
            <summary>
            Implements a 32-bit CRC hash algorithm compatible with Zip etc.
            </summary>
            <remarks>
            Crc32 should only be used for backward compatibility with older file formats
            and algorithms. It is not secure enough for new applications.
            If you need to call multiple times for the same data either use the HashAlgorithm
            interface or remember that the result of one Compute call needs to be ~ (XOR) before
            being passed in as the seed for the next Compute call.
            </remarks>
        </member>
        <member name="F:Misho.Security.Cryptography.DamiengCrc32.DefaultPolynomial">
            <summary>
            DefaultPolynomial
            </summary>
        </member>
        <member name="F:Misho.Security.Cryptography.DamiengCrc32.DefaultSeed">
            <summary>
            DefaultSeed
            </summary>
        </member>
        <member name="F:Misho.Security.Cryptography.DamiengCrc32.crc32Table">
            <summary>
            Table of CRC-32's of all single byte values (made by makecrc.c) 
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="polynomial"></param>
            <param name="seed"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.Initialize">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            HashCore
            </summary>
            <param name="array"></param>
            <param name="ibStart"></param>
            <param name="cbSize"></param>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.HashFinal">
            <summary>
            HashFinal
            </summary>
            <returns></returns>
        </member>
        <member name="P:Misho.Security.Cryptography.DamiengCrc32.HashSize">
            <summary>
            HashSize
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.Compute(System.Byte[])">
            <summary>
            Compute
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.Compute(System.UInt32,System.Byte[])">
            <summary>
            Compute
            </summary>
            <param name="seed"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.Compute(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Compute
            </summary>
            <param name="polynomial"></param>
            <param name="seed"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.InitializeTable(System.UInt32)">
            <summary>
            InitializeTable
            </summary>
            <param name="polynomial"></param>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.CalculateHash(System.UInt32[],System.UInt32,System.Collections.Generic.IList{System.Byte},System.Int32,System.Int32)">
            <summary>
            CalculateHash
            </summary>
            <param name="table"></param>
            <param name="seed"></param>
            <param name="buffer"></param>
            <param name="start"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Misho.Security.Cryptography.DamiengCrc32.UInt32ToBigEndianBytes(System.UInt32)">
            <summary>
            UInt32ToBigEndianBytes
            </summary>
            <param name="uint32"></param>
            <returns></returns>
        </member>
        <member name="T:Misho.Security.Cryptography.ForceCrc32">
            <summary>
            Implementation of CRC-32.
            This class supports several convenient static methods returning the CRC as UInt32.
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Misho.Security.Cryptography.ForceCrc32"/> class. 
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.Append(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes CRC-32 from multiple buffers.
            Call this method multiple times to chain multiple buffers.
            </summary>
            <param name="initial">
            Initial CRC value for the algorithm. It is zero for the first buffer.
            Subsequent buffers should have their initial value set to CRC value returned by previous call to this method.
            </param>
            <param name="input">Input buffer with data to be checksummed.</param>
            <param name="offset">Offset of the input data within the buffer.</param>
            <param name="length">Length of the input data in the buffer.</param>
            <returns>Accumulated CRC-32 of all buffers processed so far.</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.Append(System.UInt32,System.Byte[])">
            <summary>
            Computes CRC-3C from multiple buffers.
            Call this method multiple times to chain multiple buffers.
            </summary>
            <param name="initial">
            Initial CRC value for the algorithm. It is zero for the first buffer.
            Subsequent buffers should have their initial value set to CRC value returned by previous call to this method.
            </param>
            <param name="input">Input buffer containing data to be checksummed.</param>
            <returns>Accumulated CRC-32 of all buffers processed so far.</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes CRC-32 from input buffer.
            </summary>
            <param name="input">Input buffer with data to be checksummed.</param>
            <param name="offset">Offset of the input data within the buffer.</param>
            <param name="length">Length of the input data in the buffer.</param>
            <returns>CRC-32 of the data in the buffer.</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.Compute(System.Byte[])">
            <summary>
            Computes CRC-32 from input buffer.
            </summary>
            <param name="input">Input buffer containing data to be checksummed.</param>
            <returns>CRC-32 of the buffer.</returns>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.Initialize">
            <summary>
            Resets internal state of the algorithm. Used internally.
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Appends CRC-32 from given buffer
            </summary>
        </member>
        <member name="M:Misho.Security.Cryptography.ForceCrc32.HashFinal">
            <summary>
            Computes CRC-32 from <see cref="M:Misho.Security.Cryptography.ForceCrc32.HashCore(System.Byte[],System.Int32,System.Int32)"/>
            </summary>
        </member>
    </members>
</doc>
